<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="js," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="学习浏览器的断开，单步执行等用法（相见恨晚、以后不用console.log()啦！）  最好不要一行写两个语句。  要特别注意相等运算符==。JavaScript在设计时，有两种比较运算符： 第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果； 第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 由于JavaScript这">
<meta name="keywords" content="js">
<meta property="og:type" content="article">
<meta property="og:title" content="学习廖雪峰的JS教程提取笔记">
<meta property="og:url" content="http://blog.hongliang.fun/archives/2018/09/15/学习廖雪峰的JS教程提取笔记/index.html">
<meta property="og:site_name" content="Activeliang&#39;s Blog">
<meta property="og:description" content="学习浏览器的断开，单步执行等用法（相见恨晚、以后不用console.log()啦！）  最好不要一行写两个语句。  要特别注意相等运算符==。JavaScript在设计时，有两种比较运算符： 第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果； 第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 由于JavaScript这">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://biwenying-1254277363.cos.ap-guangzhou.myqcloud.com/2018-09-09-133541.png">
<meta property="og:image" content="https://cdn.liaoxuefeng.com/cdn/files/attachments/001435287613668a73ab76ccc85411282c1b1370be41636000/l">
<meta property="og:image" content="https://cdn.liaoxuefeng.com/cdn/files/attachments/001439872160923ca15925ec79f4692a98404ddb2ed5503000/l">
<meta property="og:updated_time" content="2021-03-24T03:31:08.055Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="学习廖雪峰的JS教程提取笔记">
<meta name="twitter:description" content="学习浏览器的断开，单步执行等用法（相见恨晚、以后不用console.log()啦！）  最好不要一行写两个语句。  要特别注意相等运算符==。JavaScript在设计时，有两种比较运算符： 第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果； 第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 由于JavaScript这">
<meta name="twitter:image" content="https://biwenying-1254277363.cos.ap-guangzhou.myqcloud.com/2018-09-09-133541.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.hongliang.fun/archives/2018/09/15/学习廖雪峰的JS教程提取笔记/"/>





  <title>学习廖雪峰的JS教程提取笔记 | Activeliang's Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d0b26f3d65e65e5341c195298c05378d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Activeliang's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">黄鸿亮的博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            主页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            目录
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.hongliang.fun/archives/2018/09/15/学习廖雪峰的JS教程提取笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄鸿亮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://biwenying-1254277363.cos.ap-guangzhou.myqcloud.com/2019-01-18-WX20190118-225801%402x.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Activeliang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">学习廖雪峰的JS教程提取笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-15T00:45:27+08:00">
                2018-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/15/学习廖雪峰的JS教程提取笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/15/学习廖雪峰的JS教程提取笔记/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <ol>
<li><p>学习浏览器的断开，单步执行等用法（相见恨晚、以后不用<code>console.log()</code>啦！）</p>
</li>
<li><p>最好不要一行写两个语句。</p>
</li>
<li><p>要特别注意相等运算符<code>==</code>。JavaScript在设计时，有两种比较运算符：</p>
<p>第一种是<code>==</code>比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；</p>
<p>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回<code>false</code>，如果一致，再比较。</p>
<p>由于JavaScript这个设计缺陷，<em>不要</em>使用<code>==</code>比较，始终坚持使用<code>===</code>比较。</p>
</li>
<li><p>另一个例外是<code>NaN</code>这个特殊的Number与所有其他值都不相等，包括它自己：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NaN === NaN; // false</div></pre></td></tr></table></figure>
<p>唯一能判断<code>NaN</code>的方法是通过<code>isNaN()</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">isNaN(NaN); // true</div></pre></td></tr></table></figure>
</li>
<li><h4 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h4><p><code>null</code>表示一个“空”的值，它和<code>0</code>以及空字符串<code>&#39;&#39;</code>不同，<code>0</code>是一个数值，<code>&#39;&#39;</code>表示长度为0的字符串，而<code>null</code>表示“空”。</p>
<p>在其他语言中，也有类似JavaScript的<code>null</code>的表示，例如Java也用<code>null</code>，Swift用<code>nil</code>，Python用<code>None</code>表示。但是，在JavaScript中，还有一个和<code>null</code>类似的<code>undefined</code>，它表示“未定义”。</p>
<p>JavaScript的设计者希望用<code>null</code>表示一个空的值，而<code>undefined</code>表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用<code>null</code>。<code>undefined</code>仅仅在判断函数参数是否传递的情况下有用。</p>
</li>
<li><p>对象里的键可以称为是对象的属性。可以直接用<code>object.key</code></p>
</li>
<li><h5 id="动态语言与静态语言"><a href="#动态语言与静态语言" class="headerlink" title="动态语言与静态语言"></a>动态语言与静态语言</h5><p>这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int a = 123; // a是整数类型变量，类型用int申明</div><div class="line">a = &quot;ABC&quot;; // 错误：不能把字符串赋给整型变量</div></pre></td></tr></table></figure>
<p>和静态语言相比，动态语言更灵活，就是这个原因。</p>
</li>
</ol>
<h4 id="字符串、数组"><a href="#字符串、数组" class="headerlink" title="字符串、数组"></a>字符串、数组</h4><ol>
<li><h6 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h6><p>由于多行字符串用<code>\n</code>写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号 <em>`</em> … <em>`</em> 表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">`这是一个</div><div class="line">多行</div><div class="line">字符串`;</div></pre></td></tr></table></figure>
</li>
<li><p>如果有很多变量需要连接，用<code>+</code>号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var name = &apos;小明&apos;;</div><div class="line">var age = 20;</div><div class="line">var message = `你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!`;</div><div class="line">alert(message);</div></pre></td></tr></table></figure>
</li>
<li><p>indexOf</p>
<p><code>indexOf()</code>会搜索指定字符串出现的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var s = &apos;hello, world&apos;;</div><div class="line">s.indexOf(&apos;world&apos;); // 返回7</div><div class="line">s.indexOf(&apos;World&apos;); // 没有找到指定的子串，返回-1</div></pre></td></tr></table></figure>
</li>
<li><p>substring</p>
<p><code>substring()</code>返回指定索引区间的子串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var s = &apos;hello, world&apos;</div><div class="line">s.substring(0, 5); // 从索引0开始到5（不包括5），返回&apos;hello&apos;</div><div class="line">s.substring(7); // 从索引7开始到结束，返回&apos;world&apos;</div></pre></td></tr></table></figure>
</li>
<li><p><em>请注意</em>，如果通过索引赋值时，索引超过了范围，同样会引起<code>Array</code>大小的变化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var arr = [1, 2, 3];</div><div class="line">arr[5] = &apos;x&apos;;</div><div class="line">arr; // arr变为[1, 2, 3, undefined, undefined, &apos;x&apos;]</div></pre></td></tr></table></figure>
<p>大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的<code>Array</code>却不会有任何错误。在编写代码时，不建议直接修改<code>Array</code>的大小，访问索引时要确保索引不会越界。</p>
</li>
<li><p>slice</p>
<p><code>slice()</code>就是对应String的<code>substring()</code>版本，它截取<code>Array</code>的部分元素，然后返回一个新的<code>Array</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;];</div><div class="line">arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]</div><div class="line">arr.slice(3); // 从索引3开始到结束: [&apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;]</div></pre></td></tr></table></figure>
<p>注意到<code>slice()</code>的起止参数包括开始索引，不包括结束索引。</p>
<p>如果不给<code>slice()</code>传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个<code>Array</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;];</div><div class="line">var aCopy = arr.slice();</div><div class="line">aCopy; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;]</div><div class="line">aCopy === arr; // false</div></pre></td></tr></table></figure>
</li>
<li><p>数组的堆栈用法：</p>
<ul>
<li><p>push和pop</p>
<p><code>push()</code>向<code>Array</code>的末尾添加若干元素，<code>pop()</code>则把<code>Array</code>的最后一个元素删除掉：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var arr = [1, 2];</div><div class="line">arr.push(&apos;A&apos;, &apos;B&apos;); // 返回Array新的长度: 4</div><div class="line">arr; // [1, 2, &apos;A&apos;, &apos;B&apos;]</div><div class="line">arr.pop(); // pop()返回&apos;B&apos;</div><div class="line">arr; // [1, 2, &apos;A&apos;]</div><div class="line">arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次</div><div class="line">arr; // []</div><div class="line">arr.pop(); // 空数组继续pop不会报错，而是返回undefined</div><div class="line">arr; // []</div></pre></td></tr></table></figure>
</li>
<li><p>unshift和shift</p>
<p>如果要往<code>Array</code>的头部添加若干元素，使用<code>unshift()</code>方法，<code>shift()</code>方法则把<code>Array</code>的第一个元素删掉：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var arr = [1, 2];</div><div class="line">arr.unshift(&apos;A&apos;, &apos;B&apos;); // 返回Array新的长度: 4</div><div class="line">arr; // [&apos;A&apos;, &apos;B&apos;, 1, 2]</div><div class="line">arr.shift(); // &apos;A&apos;</div><div class="line">arr; // [&apos;B&apos;, 1, 2]</div><div class="line">arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次</div><div class="line">arr; // []</div><div class="line">arr.shift(); // 空数组继续shift不会报错，而是返回undefined</div><div class="line">arr; // []</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>sort排序</p>
</li>
<li><p>Reverse反序</p>
</li>
<li><p>splice</p>
<p><code>splice()</code>方法是修改<code>Array</code>的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var arr = [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;, &apos;Oracle&apos;];</div><div class="line">// 从索引2开始删除3个元素,然后再添加两个元素:</div><div class="line">arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;); // 返回删除的元素 [&apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;]</div><div class="line">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]</div><div class="line">// 只删除,不添加:</div><div class="line">arr.splice(2, 2); // [&apos;Google&apos;, &apos;Facebook&apos;]</div><div class="line">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Oracle&apos;]</div><div class="line">// 只添加,不删除:</div><div class="line">arr.splice(2, 0, &apos;Google&apos;, &apos;Facebook&apos;); // 返回[],因为没有删除任何元素</div><div class="line">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]</div></pre></td></tr></table></figure>
</li>
<li><p>concat</p>
<p><code>concat()</code>方法把当前的<code>Array</code>和另一个<code>Array</code>连接起来，并返回一个新的<code>Array</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</div><div class="line">var added = arr.concat([1, 2, 3]);</div><div class="line">added; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, 1, 2, 3]</div><div class="line">arr; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]</div></pre></td></tr></table></figure>
<p><em>请注意</em>，<code>concat()</code>方法并没有修改当前<code>Array</code>，而是返回了一个新的<code>Array</code>。</p>
<p>实际上，<code>concat()</code>方法可以接收任意个元素和<code>Array</code>，并且自动把<code>Array</code>拆开，然后全部添加到新的<code>Array</code>里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</div><div class="line">arr.concat(1, 2, [3, 4]); // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, 1, 2, 3, 4]</div></pre></td></tr></table></figure>
</li>
<li><p>join方法和ruby的类似</p>
</li>
<li><p>访问属性是通过<code>.</code>操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用<code>&#39;&#39;</code>括起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var xiaohong = &#123;</div><div class="line">    name: &apos;小红&apos;,</div><div class="line">    &apos;middle-school&apos;: &apos;No.1 Middle School&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p> 如果我们要检测<code>xiaoming</code>是否拥有某一属性，可以用<code>in</code>操作符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var xiaoming = &#123;</div><div class="line">    name: &apos;小明&apos;,</div><div class="line">    birth: 1990,</div><div class="line">    school: &apos;No.1 Middle School&apos;,</div><div class="line">    height: 1.70,</div><div class="line">    weight: 65,</div><div class="line">    score: null</div><div class="line">&#125;;</div><div class="line">&apos;name&apos; in xiaoming; // true</div><div class="line">&apos;grade&apos; in xiaoming; // false</div></pre></td></tr></table></figure>
<p>不过要小心，如果<code>in</code>判断一个属性存在，这个属性不一定是<code>xiaoming</code>的，它可能是<code>xiaoming</code>继承得到的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;toString&apos; in xiaoming; // true</div></pre></td></tr></table></figure>
<p>因为<code>toString</code>定义在<code>object</code>对象中，而所有对象最终都会在原型链上指向<code>object</code>，所以<code>xiaoming</code>也拥有<code>toString</code>属性。</p>
<p>要判断一个属性是否是<code>xiaoming</code>自身拥有的，而不是继承得到的，可以用<code>hasOwnProperty()</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var xiaoming = &#123;</div><div class="line">    name: &apos;小明&apos;</div><div class="line">&#125;;</div><div class="line">xiaoming.hasOwnProperty(&apos;name&apos;); // true</div><div class="line">xiaoming.hasOwnProperty(&apos;toString&apos;); // false</div></pre></td></tr></table></figure>
</li>
<li><p>可以省略{}在选择性语句中：var age = 20;if (age &gt;= 18) { // 如果age &gt;= 18为true，则执行if语句块    alert(‘adult’);} else { // 否则执行else语句块    alert(‘teenager’);}</p>
<p>其中<code>else</code>语句是可选的。如果语句块只包含一条语句，那么可以省略<code>{}</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var age = 20;</div><div class="line">if (age &gt;= 18)</div><div class="line">    alert(&apos;adult&apos;);</div><div class="line">else</div><div class="line">    alert(&apos;teenager&apos;);</div></pre></td></tr></table></figure>
<p>（但，不能超过一个语句！！！）</p>
</li>
<li><p>JavaScript把<code>null</code>、<code>undefined</code>、<code>0</code>、<code>NaN</code>和空字符串<code>&#39;&#39;</code>视为<code>false</code>，其他值一概视为<code>true</code></p>
</li>
<li><p>prompt可以直接通过浏览器提示框让用户输入！！！</p>
<p><img src="https://biwenying-1254277363.cos.ap-guangzhou.myqcloud.com/2018-09-09-133541.png" alt="image-20180909213540561"></p>
</li>
<li><p>循环For:</p>
<p>JavaScript的循环有两种，一种是<code>for</code>循环，通过<strong>初始条件、循环条件和递增条件</strong>来循环执行语句块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var x = 0;</div><div class="line">var i;</div><div class="line">for (i=1; i&lt;=10000; i++) &#123;</div><div class="line">    x = x + i;</div><div class="line">&#125;</div><div class="line">x; // 50005000</div></pre></td></tr></table></figure>
<p>让我们来分析一下<code>for</code>循环的控制条件：</p>
<ul>
<li><p>i=1 这是初始条件，将变量i置为1；</p>
</li>
<li><p>i&lt;=10000 这是判断条件，满足时就继续循环，不满足就退出循环；</p>
</li>
<li><p>i++ 这是每次循环后的递增条件，由于每次循环后变量i都会加1，因此它终将在若干次循环后不满足判断条件<code>i&lt;=10000</code>而退出循环。</p>
</li>
</ul>
</li>
</ol>
<pre><code>`for`循环的3个条件都是可以省略的，如果没有退出循环的判断条件，就必须使用`break`语句退出循环，否则就是死循环：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var x = 0;</div><div class="line">for (;;) &#123; // 将无限循环下去</div><div class="line">    if (x &gt; 100) &#123;</div><div class="line">        break; // 通过if判断来退出循环</div><div class="line">    &#125;</div><div class="line">    x ++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><ol>
<li><h6 id="for-…-in"><a href="#for-…-in" class="headerlink" title="for … in"></a>for … in</h6><p><code>for</code>循环的一个变体是<code>for ... in</code>循环，它可以把一个对象的所有属性依次循环出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">    name: &apos;Jack&apos;,</div><div class="line">    age: 20,</div><div class="line">    city: &apos;Beijing&apos;</div><div class="line">&#125;;</div><div class="line">for (var key in o) &#123;</div><div class="line">    console.log(key); // &apos;name&apos;, &apos;age&apos;, &apos;city&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>由于<code>Array</code>也是对象，而它的每个元素的索引被视为对象的属性，因此，<code>for ... in</code>循环可以直接循环出<code>Array</code>的索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</div><div class="line">for (var i in a) &#123;</div><div class="line">    console.log(i); // &apos;0&apos;, &apos;1&apos;, &apos;2&apos;</div><div class="line">    console.log(a[i]); // &apos;A&apos;, &apos;B&apos;, &apos;C&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>请注意</em>，<code>for ... in</code>对<code>Array</code>的循环得到的是<code>String</code>而不是<code>Number</code>。</p>
</li>
<li><h6 id="while"><a href="#while" class="headerlink" title="while"></a>while</h6><p><code>for</code>循环在已知循环的初始和结束条件时非常有用。而上述忽略了条件的<code>for</code>循环容易让人看不清循环的逻辑，此时用<code>while</code>循环更佳。</p>
<p><code>while</code>循环只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var x = 0;</div><div class="line">var n = 99;</div><div class="line">while (n &gt; 0) &#123;</div><div class="line">    x = x + n;</div><div class="line">    n = n - 2;</div><div class="line">&#125;</div><div class="line">x; // 2500</div></pre></td></tr></table></figure>
<p>在循环内部变量<code>n</code>不断自减，直到变为<code>-1</code>时，不再满足<code>while</code>条件，循环退出。</p>
</li>
<li><h6 id="do-…-while"><a href="#do-…-while" class="headerlink" title="do … while"></a>do … while</h6><p>最后一种循环是<code>do { ... } while()</code>循环，它和<code>while</code>循环的唯一区别在于，不是在每次循环开始的时候判断条件，而是在每次循环完成的时候判断条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var n = 0;</div><div class="line">do &#123;</div><div class="line">    n = n + 1;</div><div class="line">&#125; while (n &lt; 100);</div><div class="line">n; // 100</div></pre></td></tr></table></figure>
<p>用<code>do { ... } while()</code>循环要小心，循环体会至少执行1次，而<code>for</code>和<code>while</code>循环则可能一次都不执行。</p>
</li>
</ol>
<blockquote>
<p>5种循环方式：</p>
<ul>
<li>for(起始条件；循环条件；递增条件)……</li>
<li>For….in…..</li>
<li>while……</li>
<li>Do……while…..</li>
<li>数组的<code>forEach()</code></li>
</ul>
</blockquote>
<ol>
<li><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p><code>Map</code>是一组键值对的结构，具有<strong>极快的查找速度</strong>。</p>
<p>举个例子，假设要根据同学的名字查找对应的成绩，如果用<code>Array</code>实现，需要两个<code>Array</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var names = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;];</div><div class="line">var scores = [95, 75, 85];</div></pre></td></tr></table></figure>
<p>给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。</p>
<p>如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，<strong>查找速度都不会变慢</strong>。用JavaScript写一个Map如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var m = new Map([[&apos;Michael&apos;, 95], [&apos;Bob&apos;, 75], [&apos;Tracy&apos;, 85]]);</div><div class="line">m.get(&apos;Michael&apos;); // 95</div></pre></td></tr></table></figure>
<p>初始化<code>Map</code>需要一个二维数组，或者直接初始化一个空<code>Map</code>。<code>Map</code>具有以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var m = new Map(); // 空Map</div><div class="line">m.set(&apos;Adam&apos;, 67); // 添加新的key-value</div><div class="line">m.set(&apos;Bob&apos;, 59);</div><div class="line">m.has(&apos;Adam&apos;); // 是否存在key &apos;Adam&apos;: true</div><div class="line">m.get(&apos;Adam&apos;); // 67</div><div class="line">m.delete(&apos;Adam&apos;); // 删除key &apos;Adam&apos;</div><div class="line">m.get(&apos;Adam&apos;); // undefined</div></pre></td></tr></table></figure>
</li>
<li><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p><code>Set</code>和<code>Map</code>类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在<code>Set</code>中，没有重复的key。</p>
<p>要创建一个<code>Set</code>，需要提供一个<code>Array</code>作为输入，或者直接创建一个空<code>Set</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var s1 = new Set(); // 空Set</div><div class="line">var s2 = new Set([1, 2, 3]); // 含1, 2, 3</div></pre></td></tr></table></figure>
<p>重复元素在<code>Set</code>中自动被过滤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var s = new Set([1, 2, 3, 3, &apos;3&apos;]);</div><div class="line">s; // Set &#123;1, 2, 3, &quot;3&quot;&#125;</div></pre></td></tr></table></figure>
<p>注意数字<code>3</code>和字符串<code>&#39;3&#39;</code>是不同的元素。</p>
<p>通过<code>add(key)</code>方法可以添加元素到<code>Set</code>中，可以重复添加，但不会有效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">s.add(4);</div><div class="line">s; // Set &#123;1, 2, 3, 4&#125;</div><div class="line">s.add(4);</div><div class="line">s; // 仍然是 Set &#123;1, 2, 3, 4&#125;</div></pre></td></tr></table></figure>
<p>通过<code>delete(key)</code>方法可以删除元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var s = new Set([1, 2, 3]);</div><div class="line">s; // Set &#123;1, 2, 3&#125;</div><div class="line">s.delete(3);</div><div class="line">s; // Set &#123;1, 2&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>这两个有点像redis里的方法。</p>
</blockquote>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ol>
<li><p>匿名函数：<code>function (x) { ... }</code></p>
</li>
<li><p>函数的传参数量没有严格限定。可以少也可以多个，在函数内部可以用<code>arguments</code> 把所有的参数当一个数组来调用。但这种方法在函数内部需要自己写语句来判断，显得有点别扭。新的做法是：<code>…rest</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo(a, b, ...rest) &#123;</div><div class="line">    console.log(&apos;a = &apos; + a);</div><div class="line">    console.log(&apos;b = &apos; + b);</div><div class="line">    console.log(rest);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><h6 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h6><p>JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">    var x = &apos;Hello, &apos; + y;</div><div class="line">    console.log(x);</div><div class="line">    var y = &apos;Bob&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo();</div><div class="line"></div><div class="line">相当于：</div><div class="line"></div><div class="line">function foo() &#123;</div><div class="line">    var y; // 提升变量y的申明，此时y为undefined</div><div class="line">    var x = &apos;Hello, &apos; + y;</div><div class="line">    console.log(x);</div><div class="line">    y = &apos;Bob&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以：通常会在定义函数伊始就定义好所有的变量！</p>
</li>
<li><h6 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h6><p>不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象<code>window</code>，全局作用域的变量实际上被绑定到<code>window</code>的一个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line"></div><div class="line">var course = &apos;Learn JavaScript&apos;;</div><div class="line">alert(course); // &apos;Learn JavaScript&apos;</div><div class="line">alert(window.course); // &apos;Learn JavaScript&apos;</div></pre></td></tr></table></figure>
<p>因此，直接访问全局变量<code>course</code>和访问<code>window.course</code>是完全一样的。</p>
</li>
<li><h6 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h6><p>全局变量会绑定到<code>window</code>上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。</p>
<p>减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 唯一的全局变量MYAPP:</div><div class="line">var MYAPP = &#123;&#125;;</div><div class="line"></div><div class="line">// 其他变量:</div><div class="line">MYAPP.name = &apos;myapp&apos;;</div><div class="line">MYAPP.version = 1.0;</div><div class="line"></div><div class="line">// 其他函数:</div><div class="line">MYAPP.foo = function () &#123;</div><div class="line">    return &apos;foo&apos;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>原来还有命名空间这么一说。</p>
</blockquote>
</li>
<li><h5 id="常量（这里把let-和-const讲得很接地气！）"><a href="#常量（这里把let-和-const讲得很接地气！）" class="headerlink" title="常量（这里把let 和 const讲得很接地气！）"></a>常量（这里把let 和 const讲得很接地气！）</h5><p>由于<code>var</code>和<code>let</code>申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var PI = 3.14;</div></pre></td></tr></table></figure>
<p>ES6标准引入了新的关键字<code>const</code>来定义常量，<code>const</code>与<code>let</code>都具有块级作用域：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line"></div><div class="line">const PI = 3.14;</div><div class="line">PI = 3; // 某些浏览器不报错，但是无效果！</div><div class="line">PI; // 3.14</div></pre></td></tr></table></figure>
</li>
<li><p>快速赋值和提取属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &apos;小明&apos;,</div><div class="line">    age: 20,</div><div class="line">    gender: &apos;male&apos;,</div><div class="line">    passport: &apos;G-12345678&apos;,</div><div class="line">    school: &apos;No.4 middle school&apos;</div><div class="line">&#125;;</div><div class="line">var &#123;name, age, passport&#125; = person;</div></pre></td></tr></table></figure>
<p>还可以有默认值：666</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &apos;小明&apos;,</div><div class="line">    age: 20,</div><div class="line">    gender: &apos;male&apos;,</div><div class="line">    passport: &apos;G-12345678&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 如果person对象没有single属性，默认赋值为true:</div><div class="line">var &#123;name, single=true&#125; = person;</div><div class="line">name; // &apos;小明&apos;</div><div class="line">single; // true</div></pre></td></tr></table></figure>
<p>对象的解构还是蛮方便的！<strong>直接用对象来解构</strong></p>
<p>如果一个函数接收一个对象作为参数，那么，可以使用解构直接把对象的属性绑定到变量中。例如，下面的函数可以快速创建一个<code>Date</code>对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function buildDate(&#123;year, month, day, hour=0, minute=0, second=0&#125;) &#123;</div><div class="line">    return new Date(year + &apos;-&apos; + month + &apos;-&apos; + day + &apos; &apos; + hour + &apos;:&apos; + minute + &apos;:&apos; + second);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol>
<li><p>在一个对象中绑定函数，称为这个对象的方法。</p>
<p>在JavaScript中，对象的定义是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var xiaoming = &#123;</div><div class="line">    name: &apos;小明&apos;,</div><div class="line">    birth: 1990</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>但是，如果我们给<code>xiaoming</code>绑定一个函数，就可以做更多的事情。比如，写个<code>age()</code>方法，返回<code>xiaoming</code>的年龄：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var xiaoming = &#123;</div><div class="line">    name: &apos;小明&apos;,</div><div class="line">    birth: 1990,</div><div class="line">    age: function () &#123;</div><div class="line">        var y = new Date().getFullYear();</div><div class="line">        return y - this.birth;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xiaoming.age; // function xiaoming.age()</div><div class="line">xiaoming.age(); // 今年调用是25,明年调用就变成26了</div></pre></td></tr></table></figure>
</li>
<li><p>this指的是调用者本身。（这里有坑需要注意！）</p>
</li>
<li><h5 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h5><p>虽然在一个独立的函数调用中，根据是否是strict模式，<code>this</code>指向<code>undefined</code>或<code>window</code>，不过，我们还是可以控制<code>this</code>的指向的！</p>
<p>要指定函数的<code>this</code>指向哪个对象，可以用函数本身的<code>apply</code>方法，它接收两个参数，第一个参数就是需要绑定的<code>this</code>变量，第二个参数是<code>Array</code>，表示函数本身的参数。</p>
<p>用<code>apply</code>修复<code>getAge()</code>调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function getAge() &#123;</div><div class="line">    var y = new Date().getFullYear();</div><div class="line">    return y - this.birth;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var xiaoming = &#123;</div><div class="line">    name: &apos;小明&apos;,</div><div class="line">    birth: 1990,</div><div class="line">    age: getAge</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xiaoming.age(); // 25</div><div class="line">getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><blockquote>
<p>JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为<strong><code>高阶函数</code></strong>。</p>
</blockquote>
<ol>
<li><h5 id="map和reduce"><a href="#map和reduce" class="headerlink" title="map和reduce"></a>map和reduce</h5><p>要把<code>[1, 3, 5, 7, 9]</code>变换成整数13579，<code>reduce()</code>也能派上用场：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var arr = [1, 3, 5, 7, 9];</div><div class="line">arr.reduce(function (x, y) &#123;</div><div class="line">    return x * 10 + y;</div><div class="line">&#125;); // 13579</div></pre></td></tr></table></figure>
<p>和rails基本无差，只是在调用的时候用法上有点小差别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function pow(x) &#123;</div><div class="line">    return x * x;</div><div class="line">&#125;</div><div class="line">var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];</div><div class="line">var results = arr.map(pow); //这里调用时，直接就自动传参啦，233</div></pre></td></tr></table></figure>
</li>
<li><p>filter函数：</p>
<p>把一个<code>Array</code>中的空字符串删掉，可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var arr = [&apos;A&apos;, &apos;&apos;, &apos;B&apos;, null, undefined, &apos;C&apos;, &apos;  &apos;];</div><div class="line">var r = arr.filter(function (s) &#123;</div><div class="line">    return s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法</div><div class="line">&#125;);</div><div class="line">r; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]</div></pre></td></tr></table></figure>
<p> 把返回false的参数过滤掉！</p>
</li>
<li><h5 id="Sort函数"><a href="#Sort函数" class="headerlink" title="Sort函数"></a>Sort函数</h5><h5 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h5><p>排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个对象呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。通常规定，对于两个元素<code>x</code>和<code>y</code>，如果认为<code>x &lt; y</code>，则返回<code>-1</code>，如果认为<code>x == y</code>，则返回<code>0</code>，如果认为<code>x &gt; y</code>，则返回<code>1</code>，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。</p>
<p>JavaScript的<code>Array</code>的<code>sort()</code>方法就是用于排序的，但是排序结果可能让你大吃一惊：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 看上去正常的结果:</div><div class="line">[&apos;Google&apos;, &apos;Apple&apos;, &apos;Microsoft&apos;].sort(); // [&apos;Apple&apos;, &apos;Google&apos;, &apos;Microsoft&apos;];</div><div class="line"></div><div class="line">// apple排在了最后:</div><div class="line">[&apos;Google&apos;, &apos;apple&apos;, &apos;Microsoft&apos;].sort(); // [&apos;Google&apos;, &apos;Microsoft&quot;, &apos;apple&apos;]</div><div class="line"></div><div class="line">// 无法理解的结果:</div><div class="line">[10, 20, 1, 2].sort(); // [1, 10, 2, 20]</div></pre></td></tr></table></figure>
<p>js 的排序方法绝对是大坑！</p>
<h5 id="改进："><a href="#改进：" class="headerlink" title="改进："></a>改进：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var arr = [10, 20, 1, 2];</div><div class="line">arr.sort(function (x, y) &#123;</div><div class="line">    if (x &lt; y) &#123;</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    if (x &gt; y) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;);</div><div class="line">console.log(arr); // [1, 2, 10, 20]</div></pre></td></tr></table></figure>
<p>sort方法会直接改变数组本身！</p>
</li>
</ol>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x =&gt; x * x</div></pre></td></tr></table></figure>
<p>上面的箭头函数相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function (x) &#123;</div><div class="line">    return x * x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连<code>{ ... }</code>和<code>return</code>都省略掉了。还有一种可以包含多条语句，这时候就不能省略<code>{ ... }</code>和<code>return</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">x =&gt; &#123;</div><div class="line">    if (x &gt; 0) &#123;</div><div class="line">        return x * x;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        return - x * x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果参数不是一个，就需要用括号<code>()</code>括起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 两个参数:</div><div class="line">(x, y) =&gt; x * x + y * y</div><div class="line"></div><div class="line">// 无参数:</div><div class="line">() =&gt; 3.14</div><div class="line"></div><div class="line">// 可变参数:</div><div class="line">(x, y, ...rest) =&gt; &#123;</div><div class="line">    var i, sum = x + y;</div><div class="line">    for (i=0; i&lt;rest.length; i++) &#123;</div><div class="line">        sum += rest[i];</div><div class="line">    &#125;</div><div class="line">    return sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// SyntaxError:</div><div class="line">x =&gt; &#123; foo: x &#125;</div></pre></td></tr></table></figure>
<p>因为和函数体的<code>{ ... }</code>有语法冲突，所以要改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// ok:</div><div class="line">x =&gt; (&#123; foo: x &#125;)</div></pre></td></tr></table></figure>
<h5 id="重点！"><a href="#重点！" class="headerlink" title="重点！"></a>重点！</h5><p>箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的<code>this</code>是词法作用域，由上下文确定。</p>
<p>回顾前面的例子，由于JavaScript函数对<code>this</code>绑定的错误处理，下面的例子无法得到预期结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">    birth: 1990,</div><div class="line">    getAge: function () &#123;</div><div class="line">        var b = this.birth; // 1990</div><div class="line">        var fn = function () &#123;</div><div class="line">            return new Date().getFullYear() - this.birth; // this指向window或undefined</div><div class="line">        &#125;;</div><div class="line">        return fn();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>现在，箭头函数完全修复了<code>this</code>的指向，<code>this</code>总是指向词法作用域，也就是外层调用者<code>obj</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">    birth: 1990,</div><div class="line">    getAge: function () &#123;</div><div class="line">        var b = this.birth; // 1990</div><div class="line">        var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象</div><div class="line">        return fn();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">obj.getAge(); // 25</div></pre></td></tr></table></figure>
<p>如果使用箭头函数，以前的那种hack写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var that = this;</div></pre></td></tr></table></figure>
<p>就不再需要了。万岁！</p>
<h5 id="总结箭头函数："><a href="#总结箭头函数：" class="headerlink" title="总结箭头函数："></a>总结箭头函数：</h5><blockquote>
<ol>
<li>简化</li>
<li>自动指定this</li>
<li>没有参数也需要用括号</li>
<li>call和apply方法无法再用this来传数。</li>
</ol>
</blockquote>
<h4 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h4><p>generator还有另一个巨大的好处，就是把异步回调代码变成“同步”代码。这个好处要等到后面学了AJAX以后才能体会到。</p>
<p>没有generator之前的黑暗时代，用AJAX时需要这么写代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">ajax(&apos;http://url-1&apos;, data1, function (err, result) &#123;</div><div class="line">    if (err) &#123;</div><div class="line">        return handle(err);</div><div class="line">    &#125;</div><div class="line">    ajax(&apos;http://url-2&apos;, data2, function (err, result) &#123;</div><div class="line">        if (err) &#123;</div><div class="line">            return handle(err);</div><div class="line">        &#125;</div><div class="line">        ajax(&apos;http://url-3&apos;, data3, function (err, result) &#123;</div><div class="line">            if (err) &#123;</div><div class="line">                return handle(err);</div><div class="line">            &#125;</div><div class="line">            return success(result);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>回调越多，代码越难看。</p>
<p>有了generator的美好时代，用AJAX时可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">    r1 = yield ajax(&apos;http://url-1&apos;, data1);</div><div class="line">    r2 = yield ajax(&apos;http://url-2&apos;, data2);</div><div class="line">    r3 = yield ajax(&apos;http://url-3&apos;, data3);</div><div class="line">    success(r3);</div><div class="line">&#125;</div><div class="line">catch (err) &#123;</div><div class="line">    handle(err);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>点评：用法就是遇到yield的时候暂停，返回return一下yield后面返回的值，等函数再次调用时再运行下一步！</p>
</blockquote>
<h4 id="Date函数"><a href="#Date函数" class="headerlink" title="Date函数"></a>Date函数</h4><blockquote>
<p>关于时间的一些方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var now = new Date();</div><div class="line">now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</div><div class="line">now.getFullYear(); // 2015, 年份</div><div class="line">now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月</div><div class="line">now.getDate(); // 24, 表示24号</div><div class="line">now.getDay(); // 3, 表示星期三</div><div class="line">now.getHours(); // 19, 24小时制</div><div class="line">now.getMinutes(); // 49, 分钟</div><div class="line">now.getSeconds(); // 22, 秒</div><div class="line">now.getMilliseconds(); // 875, 毫秒数</div><div class="line">now.getTime(); // 1435146562875, 以number形式表示的时间戳</div><div class="line"></div><div class="line">var test = Date.now() //1536800166989</div><div class="line">var d = new Date(1435146562875);</div><div class="line">d.toLocaleString(); // &apos;2015/6/24 下午7:49:22&apos;，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关</div><div class="line">d.toUTCString();</div><div class="line"></div><div class="line">var d = new Date(2015, 5, 19, 20, 15, 30, 123);</div><div class="line">d; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST)</div></pre></td></tr></table></figure>
<h5 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var re = /^\d&#123;3&#125;\-\d&#123;3,8&#125;$/;</div><div class="line">re.test(&apos;010-12345&apos;); // true</div><div class="line">re.test(&apos;010-1234x&apos;); // false</div><div class="line">re.test(&apos;010 12345&apos;); // false</div></pre></td></tr></table></figure>
<h6 id="1-切分字符串"><a href="#1-切分字符串" class="headerlink" title="1. 切分字符串"></a>1. 切分字符串</h6><p>用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;a b   c&apos;.split(&apos; &apos;); // [&apos;a&apos;, &apos;b&apos;, &apos;&apos;, &apos;&apos;, &apos;c&apos;]</div></pre></td></tr></table></figure>
<p>嗯，无法识别连续的空格，用正则表达式试试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;a b   c&apos;.split(/\s+/); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</div></pre></td></tr></table></figure>
<blockquote>
<p>这里原来有这样更好的用法！！！！</p>
</blockquote>
<h6 id="2-分组"><a href="#2-分组" class="headerlink" title="2. 分组"></a>2. 分组</h6><p>除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用<code>()</code>表示的就是要提取的分组（Group）。比如：</p>
<p><code>^(\d{3})-(\d{3,8})$</code>分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var re = /^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$/;</div><div class="line">re.exec(&apos;010-12345&apos;); // [&apos;010-12345&apos;, &apos;010&apos;, &apos;12345&apos;]</div><div class="line">re.exec(&apos;010 12345&apos;); // null</div></pre></td></tr></table></figure>
<p>如果正则表达式中定义了组，就可以在<code>RegExp</code>对象上用<code>exec()</code>方法提取出子串来。</p>
<p><code>exec()</code>方法在匹配成功后，会返回一个<code>Array</code>，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。</p>
<p><code>exec()</code>方法在匹配失败时返回<code>null</code>。</p>
<h6 id="3-贪婪匹配"><a href="#3-贪婪匹配" class="headerlink" title="3. 贪婪匹配"></a>3. 贪婪匹配</h6><p>需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的<code>0</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var re = /^(\d+)(0*)$/;</div><div class="line">re.exec(&apos;102300&apos;); // [&apos;102300&apos;, &apos;102300&apos;, &apos;&apos;]</div></pre></td></tr></table></figure>
<p>由于<code>\d+</code>采用贪婪匹配，直接把后面的<code>0</code>全部匹配了，结果<code>0*</code>只能匹配空字符串了。</p>
<p>必须让<code>\d+</code>采用非贪婪匹配（也就是尽可能少匹配），才能把后面的<code>0</code>匹配出来，加个<code>?</code>就可以让<code>\d+</code>采用非贪婪匹配：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var re = /^(\d+?)(0*)$/;</div><div class="line">re.exec(&apos;102300&apos;); // [&apos;102300&apos;, &apos;1023&apos;, &apos;00&apos;]</div></pre></td></tr></table></figure>
<h6 id="4-全局搜索"><a href="#4-全局搜索" class="headerlink" title="4. 全局搜索"></a>4. 全局搜索</h6><p>JavaScript的正则表达式还有几个特殊的标志，最常用的是<code>g</code>，表示全局匹配：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var r1 = /test/g;</div><div class="line">// 等价于:</div><div class="line">var r2 = new RegExp(&apos;test&apos;, &apos;g&apos;);</div></pre></td></tr></table></figure>
<p>全局匹配可以多次执行<code>exec()</code>方法来搜索一个匹配的字符串。当我们指定<code>g</code>标志后，每次运行<code>exec()</code>，正则表达式本身会更新<code>lastIndex</code>属性，表示上次匹配到的最后索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var s = &apos;JavaScript, VBScript, JScript and ECMAScript&apos;;</div><div class="line">var re=/[a-zA-Z]+Script/g;</div><div class="line"></div><div class="line">// 使用全局匹配:</div><div class="line">re.exec(s); // [&apos;JavaScript&apos;]</div><div class="line">re.lastIndex; // 10</div><div class="line"></div><div class="line">re.exec(s); // [&apos;VBScript&apos;]</div><div class="line">re.lastIndex; // 20</div><div class="line"></div><div class="line">re.exec(s); // [&apos;JScript&apos;]</div><div class="line">re.lastIndex; // 29</div><div class="line"></div><div class="line">re.exec(s); // [&apos;ECMAScript&apos;]</div><div class="line">re.lastIndex; // 44</div><div class="line"></div><div class="line">re.exec(s); // null，直到结束仍没有匹配到</div></pre></td></tr></table></figure>
<p>全局匹配类似搜索，因此不能使用<code>/^...$/</code>，那样只会最多匹配一次。</p>
<p>正则表达式还可以指定<code>i</code>标志，表示忽略大小写，<code>m</code>标志，表示执行多行匹配。</p>
<h4 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14,&quot;gender&quot;:true,&quot;height&quot;:1.65,&quot;grade&quot;:null,&quot;middle-school&quot;:&quot;\&quot;W3C\&quot; Middle School&quot;,&quot;skills&quot;:[&quot;JavaScript&quot;,&quot;Java&quot;,&quot;Python&quot;,&quot;Lisp&quot;]&#125;</div></pre></td></tr></table></figure>
<p>要输出得好看一些，可以加上参数，按缩进输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JSON.stringify(xiaoming, null, &apos;  &apos;);</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;小明&quot;,</div><div class="line">  &quot;age&quot;: 14,</div><div class="line">  &quot;gender&quot;: true,</div><div class="line">  &quot;height&quot;: 1.65,</div><div class="line">  &quot;grade&quot;: null,</div><div class="line">  &quot;middle-school&quot;: &quot;\&quot;W3C\&quot; Middle School&quot;,</div><div class="line">  &quot;skills&quot;: [</div><div class="line">    &quot;JavaScript&quot;,</div><div class="line">    &quot;Java&quot;,</div><div class="line">    &quot;Python&quot;,</div><div class="line">    &quot;Lisp&quot;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>序列化和反序列化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">JSON.stringify();</div><div class="line">JSON.parse()</div></pre></td></tr></table></figure>
<h4 id="javascript面向对象"><a href="#javascript面向对象" class="headerlink" title="javascript面向对象"></a>javascript面向对象</h4><h6 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var Student = &#123;</div><div class="line">    name: &apos;Robot&apos;,</div><div class="line">    height: 1.2,</div><div class="line">    run: function () &#123;</div><div class="line">        console.log(this.name + &apos; is running...&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var xiaoming = &#123;</div><div class="line">    name: &apos;小明&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xiaoming.__proto__ = Student;</div></pre></td></tr></table></figure>
<p>注意最后一行代码把<code>xiaoming</code>的原型指向了对象<code>Student</code>，看上去<code>xiaoming</code>仿佛是从<code>Student</code>继承下来的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xiaoming.name; // &apos;小明&apos;</div><div class="line">xiaoming.run(); // 小明 is running...</div></pre></td></tr></table></figure>
<p><code>xiaoming</code>有自己的<code>name</code>属性，但并没有定义<code>run()</code>方法。不过，由于小明是从<code>Student</code>继承而来，只要<code>Student</code>有<code>run()</code>方法，<code>xiaoming</code>也可以调用：</p>
<p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001435287613668a73ab76ccc85411282c1b1370be41636000/l" alt="xiaoming-prototype"></p>
<p>JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。</p>
<p>但通常不要这样直接<code>__proto__</code>来指定原型。</p>
<p>更好的作法：</p>
<p><code>Object.create()</code>方法可以传入一个原型对象，并创建一个基于该原型的新对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 原型对象:</div><div class="line">var Student = &#123;</div><div class="line">    name: &apos;Robot&apos;,</div><div class="line">    height: 1.2,</div><div class="line">    run: function () &#123;</div><div class="line">        console.log(this.name + &apos; is running...&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function createStudent(name) &#123;</div><div class="line">    // 基于Student原型创建一个新对象:</div><div class="line">    var s = Object.create(Student);</div><div class="line">    // 初始化新对象:</div><div class="line">    s.name = name;</div><div class="line">    return s;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var xiaoming = createStudent(&apos;小明&apos;);</div><div class="line">xiaoming.run(); // 小明 is running...</div><div class="line">xiaoming.__proto__ === Student; // true</div></pre></td></tr></table></figure>
<ol>
<li><p>不要把原型链搞得太长</p>
<p>函数也是一个对象，它的原型链是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo ----&gt; Function.prototype ----&gt; Object.prototype ----&gt; null</div></pre></td></tr></table></figure>
<p>由于<code>Function.prototype</code>定义了<code>apply()</code>等方法，因此，所有函数都可以调用<code>apply()</code>方法。</p>
<p>很容易想到，如果原型链很长，那么访问一个对象的属性就会因为花更多的时间查找而变得更慢，因此要注意不要把原型链搞得太长。</p>
</li>
<li><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><blockquote>
<p>热泪盈眶，终于知道这个是怎么回事了！</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function Student(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.hello = function () &#123;</div><div class="line">        alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你会问，咦，这不是一个普通函数吗？</p>
<p>这确实是一个普通函数，但是在JavaScript中，可以用关键字<code>new</code>来调用这个函数，并返回一个对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var xiaoming = new Student(&apos;小明&apos;);</div><div class="line">xiaoming.name; // &apos;小明&apos;</div><div class="line">xiaoming.hello(); // Hello, 小明!</div></pre></td></tr></table></figure>
<p>用<code>new Student()</code>创建的对象还从原型上获得了一个<code>constructor</code>属性，它指向函数<code>Student</code>本身：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">xiaoming.constructor === Student.prototype.constructor; // true</div><div class="line">Student.prototype.constructor === Student; // true</div><div class="line"></div><div class="line">Object.getPrototypeOf(xiaoming) === Student.prototype; // true</div><div class="line"></div><div class="line">xiaoming instanceof Student; // true</div></pre></td></tr></table></figure>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var xiaohong = new Student();</div><div class="line">var xiaoliang = new Student();</div><div class="line">xiaohong.hello() === xiaoliang.hello(); // false</div></pre></td></tr></table></figure>
<p>这里两个hello函数是各自对象里的方法。所以如果new了很多对象，就会浪费很多。解法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Student(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Student.prototype.hello = function () &#123;</div><div class="line">    alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样，xiaoming, xiaoliang下次调用是到Student找到这个方法来调用！</p>
</li>
<li><p>不要忘记写<strong>new</strong></p>
<blockquote>
<p>因为如果忘了写new， 在函数里很多属性会直接通过this增加到window，会更糟糕！So，一般构造函数通常会以大写字母开关。</p>
<p>更好的做法是，<strong>自定一个函数</strong>：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Student(props) &#123;</div><div class="line">    this.name = props.name || &apos;匿名&apos;; // 默认值为&apos;匿名&apos;</div><div class="line">    this.grade = props.grade || 1; // 默认值为1</div><div class="line">&#125;</div><div class="line"></div><div class="line">Student.prototype.hello = function () &#123;</div><div class="line">    alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function createStudent(props) &#123;</div><div class="line">    return new Student(props || &#123;&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个<code>createStudent()</code>函数有几个巨大的优点：一是不需要<code>new</code>来调用，二是参数非常灵活，可以不传，也可以这么传：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var xiaoming = createStudent(&#123;</div><div class="line">    name: &apos;小明&apos;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">xiaoming.grade; // 1</div></pre></td></tr></table></figure>
<p>如果拿到的是json数据 ，还可以直接new对象。</p>
</li>
</ol>
<h4 id="重新认识APPLE函数"><a href="#重新认识APPLE函数" class="headerlink" title="重新认识APPLE函数"></a>重新认识APPLE函数</h4><blockquote>
<p> apply就是用来<strong>改变</strong>方法内部若出现的<strong>this对象</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function getAge() &#123;</div><div class="line">    var y = new Date().getFullYear();</div><div class="line">    return y - this.birth;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var xiaoming = &#123;</div><div class="line">    name: &apos;小明&apos;,</div><div class="line">    birth: 1990,</div><div class="line">    age: getAge</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xiaoming.age(); // 25</div><div class="line">getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空</div></pre></td></tr></table></figure>
<p>apply带两个参数：第一个参数是要塞给方法内部this的对象，第二个是传给方法的参数，需要数组形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Math.max.apply(null, [3, 5, 4]); // 5</div><div class="line">Math.max.call(null, 3, 5, 4); // 5</div></pre></td></tr></table></figure>
<p>对普通函数调用，我们通常把<code>this</code>绑定为<code>null</code>。</p>
<h4 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">// PrimaryStudent构造函数:</div><div class="line">function PrimaryStudent(props) &#123;</div><div class="line">    Student.call(this, props);</div><div class="line">    this.grade = props.grade || 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 空函数F:</div><div class="line">function F() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 把F的原型指向Student.prototype:</div><div class="line">F.prototype = Student.prototype;</div><div class="line"></div><div class="line">// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:</div><div class="line">PrimaryStudent.prototype = new F();</div><div class="line"></div><div class="line">// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:</div><div class="line">PrimaryStudent.prototype.constructor = PrimaryStudent;</div><div class="line"></div><div class="line">// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：</div><div class="line">PrimaryStudent.prototype.getGrade = function () &#123;</div><div class="line">    return this.grade;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 创建xiaoming:</div><div class="line">var xiaoming = new PrimaryStudent(&#123;</div><div class="line">    name: &apos;小明&apos;,</div><div class="line">    grade: 2</div><div class="line">&#125;);</div><div class="line">xiaoming.name; // &apos;小明&apos;</div><div class="line">xiaoming.grade; // 2</div><div class="line"></div><div class="line">// 验证原型:</div><div class="line">xiaoming.__proto__ === PrimaryStudent.prototype; // true</div><div class="line">xiaoming.__proto__.__proto__ === Student.prototype; // true</div><div class="line"></div><div class="line">// 验证继承关系:</div><div class="line">xiaoming instanceof PrimaryStudent; // true</div><div class="line">xiaoming instanceof Student; // true</div></pre></td></tr></table></figure>
<p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001439872160923ca15925ec79f4692a98404ddb2ed5503000/l" alt="js-proto-extend"></p>
<h5 id="更好的作法，封装一个函数："><a href="#更好的作法，封装一个函数：" class="headerlink" title="更好的作法，封装一个函数："></a>更好的作法，封装一个函数：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function inherits(Child, Parent) &#123;</div><div class="line">    var F = function () &#123;&#125;;</div><div class="line">    F.prototype = Parent.prototype;</div><div class="line">    Child.prototype = new F();</div><div class="line">    Child.prototype.constructor = Child;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function Student(props) &#123;</div><div class="line">    this.name = props.name || &apos;Unnamed&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Student.prototype.hello = function () &#123;</div><div class="line">    alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function PrimaryStudent(props) &#123;</div><div class="line">    Student.call(this, props);</div><div class="line">    this.grade = props.grade || 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 实现原型继承链:</div><div class="line">inherits(PrimaryStudent, Student);</div><div class="line"></div><div class="line">// 绑定其他方法到PrimaryStudent原型:</div><div class="line">PrimaryStudent.prototype.getGrade = function () &#123;</div><div class="line">    return this.grade;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>终于ES6自己也看不过去了，出了个class来简化这些过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Student(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Student.prototype.hello = function () &#123;</div><div class="line">    alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果用新的<code>class</code>关键字来编写<code>Student</code>，可以这样写：</p>
<h5 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Student &#123;</div><div class="line">    constructor(name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    hello() &#123;</div><div class="line">        alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="原型的继承："><a href="#原型的继承：" class="headerlink" title="原型的继承："></a>原型的继承：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class PrimaryStudent extends Student &#123;</div><div class="line">    constructor(name, grade) &#123;</div><div class="line">        super(name); // 记得用super调用父类的构造方法!</div><div class="line">        this.grade = grade;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    myGrade() &#123;</div><div class="line">        alert(&apos;I am at grade &apos; + this.grade);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的super方法理解为调用父方法！</p>
<h5 id="帅！！！"><a href="#帅！！！" class="headerlink" title="帅！！！"></a>帅！！！</h5><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const promise = new Promise(function(resolve, reject) &#123;</div><div class="line">  // ... some code</div><div class="line"></div><div class="line">  if (/* 异步操作成功 */)&#123;</div><div class="line">    resolve(value);</div><div class="line">  &#125; else &#123;</div><div class="line">    reject(error);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>其中的resolve和reject函数作用：把promise状态切换为已完成或者失败，并把结果往外传递。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">promise</div><div class="line">.then(result =&gt; &#123;···&#125;)</div><div class="line">.catch(error =&gt; &#123;···&#125;)</div><div class="line">.finally(() =&gt; &#123;···&#125;);</div></pre></td></tr></table></figure>
<p>finally()方法是最后的回调，无论如何都会执行；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 生成一个Promise对象的数组</div><div class="line">const promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123;</div><div class="line">  return getJSON(&apos;/post/&apos; + id + &quot;.json&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Promise.all(promises).then(function (posts) &#123;</div><div class="line">  // ...</div><div class="line">&#125;).catch(function(reason)&#123;</div><div class="line">  // ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里的Promise.all相当于ruby中的线程join方法，等all中的所有方法都有回调后才往下执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const p1 = new Promise(function (resolve, reject) &#123;</div><div class="line">  // ...</div><div class="line">&#125;);</div><div class="line"></div><div class="line">const p2 = new Promise(function (resolve, reject) &#123;</div><div class="line">  // ...</div><div class="line">  resolve(p1);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这里嵌套后，p2的状态会因为p1而改变。</p>
<p>有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用<code>Promise.race()</code>实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var p1 = new Promise(function (resolve, reject) &#123;</div><div class="line">    setTimeout(resolve, 500, &apos;P1&apos;);</div><div class="line">&#125;);</div><div class="line">var p2 = new Promise(function (resolve, reject) &#123;</div><div class="line">    setTimeout(resolve, 600, &apos;P2&apos;);</div><div class="line">&#125;);</div><div class="line">Promise.race([p1, p2]).then(function (result) &#123;</div><div class="line">    console.log(result); // &apos;P1&apos;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如何往Promise里的调用函数传参数？下面是个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">const getJSON = function(url) &#123;</div><div class="line">  const promise = new Promise(function(resolve, reject)&#123;</div><div class="line">    const handler = function() &#123;</div><div class="line">      if (this.readyState !== 4) &#123;</div><div class="line">        return;</div><div class="line">      &#125;</div><div class="line">      if (this.status === 200) &#123;</div><div class="line">        resolve(this.response);</div><div class="line">      &#125; else &#123;</div><div class="line">        reject(new Error(this.statusText));</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">    const client = new XMLHttpRequest();</div><div class="line">    client.open(&quot;GET&quot;, url);</div><div class="line">    client.onreadystatechange = handler;</div><div class="line">    client.responseType = &quot;json&quot;;</div><div class="line">    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</div><div class="line">    client.send();</div><div class="line"></div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  return promise;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;</div><div class="line">  console.log(&apos;Contents: &apos; + json);</div><div class="line">&#125;, function(error) &#123;</div><div class="line">  console.error(&apos;出错了&apos;, error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="错误处理："><a href="#错误处理：" class="headerlink" title="错误处理："></a>错误处理：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">    ...</div><div class="line">&#125; catch (e) &#123;</div><div class="line">    ...</div><div class="line">&#125; finally &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="抛出错误-throw"><a href="#抛出错误-throw" class="headerlink" title="抛出错误: throw"></a>抛出错误: throw</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var r, n, s;</div><div class="line">try &#123;</div><div class="line">    s = prompt(&apos;请输入一个数字&apos;);</div><div class="line">    n = parseInt(s);</div><div class="line">    if (isNaN(n)) &#123;</div><div class="line">        throw new Error(&apos;输入错误&apos;);</div><div class="line">    &#125;</div><div class="line">    // 计算平方:</div><div class="line">    r = n * n;</div><div class="line">    console.log(n + &apos; * &apos; + n + &apos; = &apos; + r);</div><div class="line">&#125; catch (e) &#123;</div><div class="line">    console.log(&apos;出错了：&apos; + e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/js/" rel="tag"># js</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/09/13/关于闭包中用函数模仿计算的理解/" rel="next" title="关于JS闭包中用函数模仿计算的理解">
                <i class="fa fa-chevron-left"></i> 关于JS闭包中用函数模仿计算的理解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/09/21/Rails中的actionCable开放给其他网站连接/" rel="prev" title="Rails中的ActionCable开放给其他网站连接">
                Rails中的ActionCable开放给其他网站连接 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="https://biwenying-1254277363.cos.ap-guangzhou.myqcloud.com/2019-01-18-WX20190118-225801%402x.png"
              alt="黄鸿亮" />
          
            <p class="site-author-name" itemprop="name">黄鸿亮</p>
            <p class="site-description motion-element" itemprop="description">记录让我们走得更远...</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">48</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">30</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">65</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#null和undefined"><span class="nav-number">1.</span> <span class="nav-text">null和undefined</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#动态语言与静态语言"><span class="nav-number">1.1.</span> <span class="nav-text">动态语言与静态语言</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串、数组"><span class="nav-number">2.</span> <span class="nav-text">字符串、数组</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#多行字符串"><span class="nav-number">2.0.1.</span> <span class="nav-text">多行字符串</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#for-…-in"><span class="nav-number">2.0.2.</span> <span class="nav-text">for … in</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#while"><span class="nav-number">2.0.3.</span> <span class="nav-text">while</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#do-…-while"><span class="nav-number">2.0.4.</span> <span class="nav-text">do … while</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Map"><span class="nav-number">2.1.</span> <span class="nav-text">Map</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Set"><span class="nav-number">2.2.</span> <span class="nav-text">Set</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数"><span class="nav-number">3.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#变量提升"><span class="nav-number">3.0.1.</span> <span class="nav-text">变量提升</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#全局作用域"><span class="nav-number">3.0.2.</span> <span class="nav-text">全局作用域</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#名字空间"><span class="nav-number">3.0.3.</span> <span class="nav-text">名字空间</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#常量（这里把let-和-const讲得很接地气！）"><span class="nav-number">3.1.</span> <span class="nav-text">常量（这里把let 和 const讲得很接地气！）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法"><span class="nav-number">4.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#apply"><span class="nav-number">4.1.</span> <span class="nav-text">apply</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#高阶函数"><span class="nav-number">5.</span> <span class="nav-text">高阶函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#map和reduce"><span class="nav-number">5.1.</span> <span class="nav-text">map和reduce</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sort函数"><span class="nav-number">5.2.</span> <span class="nav-text">Sort函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#排序算法"><span class="nav-number">5.3.</span> <span class="nav-text">排序算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#改进："><span class="nav-number">5.4.</span> <span class="nav-text">改进：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#箭头函数"><span class="nav-number">6.</span> <span class="nav-text">箭头函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#重点！"><span class="nav-number">6.1.</span> <span class="nav-text">重点！</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#总结箭头函数："><span class="nav-number">6.2.</span> <span class="nav-text">总结箭头函数：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Generator函数"><span class="nav-number">7.</span> <span class="nav-text">Generator函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Date函数"><span class="nav-number">8.</span> <span class="nav-text">Date函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#正则表达式"><span class="nav-number">8.1.</span> <span class="nav-text">正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-切分字符串"><span class="nav-number">8.1.1.</span> <span class="nav-text">1. 切分字符串</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-分组"><span class="nav-number">8.1.2.</span> <span class="nav-text">2. 分组</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-贪婪匹配"><span class="nav-number">8.1.3.</span> <span class="nav-text">3. 贪婪匹配</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-全局搜索"><span class="nav-number">8.1.4.</span> <span class="nav-text">4. 全局搜索</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Json"><span class="nav-number">9.</span> <span class="nav-text">Json</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#javascript面向对象"><span class="nav-number">10.</span> <span class="nav-text">javascript面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#概念："><span class="nav-number">10.0.1.</span> <span class="nav-text">概念：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#构造函数"><span class="nav-number">10.1.</span> <span class="nav-text">构造函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意："><span class="nav-number">11.</span> <span class="nav-text">注意：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重新认识APPLE函数"><span class="nav-number">12.</span> <span class="nav-text">重新认识APPLE函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原型继承"><span class="nav-number">13.</span> <span class="nav-text">原型继承</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#更好的作法，封装一个函数："><span class="nav-number">13.1.</span> <span class="nav-text">更好的作法，封装一个函数：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#构造函数："><span class="nav-number">13.2.</span> <span class="nav-text">构造函数：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#原型的继承："><span class="nav-number">13.3.</span> <span class="nav-text">原型的继承：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#帅！！！"><span class="nav-number">13.4.</span> <span class="nav-text">帅！！！</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise"><span class="nav-number">14.</span> <span class="nav-text">Promise</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#错误处理："><span class="nav-number">15.</span> <span class="nav-text">错误处理：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#抛出错误-throw"><span class="nav-number">15.0.1.</span> <span class="nav-text">抛出错误: throw</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黄鸿亮</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  

    
      <script id="dsq-count-scr" src="https://honglianggithubblog.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://blog.hongliang.fun/archives/2018/09/15/学习廖雪峰的JS教程提取笔记/';
          this.page.identifier = '2018/09/15/学习廖雪峰的JS教程提取笔记/';
          this.page.title = '学习廖雪峰的JS教程提取笔记';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://honglianggithubblog.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  










  





  

  

  

  

  

  

</body>
</html>
